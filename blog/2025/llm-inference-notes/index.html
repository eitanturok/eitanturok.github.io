<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>30 Interview Questions on LLM Inference | Eitan Turok</title> <meta name="author" content="Eitan Turok"> <meta name="description" content="How many FLOPs do you save with a kv-cache? When does the kv-cache hurt?"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://eitanturok.github.io/blog/2025/llm-inference-notes/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?6185d15ea1982787ad7f435576553d64"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">{
      "title": "30 Interview Questions on LLM Inference",
      "description": "How many FLOPs do you save with a kv-cache? When does the kv-cache hurt?",
      "published": "June 30, 2025",
      "authors": [
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">Eitan Turok</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">teaching</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>30 Interview Questions on LLM Inference</h1> <p>How many FLOPs do you save with a kv-cache? When does the kv-cache hurt?</p> </d-title><d-article> <h1 id="interview-questions">Interview Questions</h1> <p>With Claude’s help, I wrote ~30 interview questions on LLM Inference: FLOPs, attention, and the kv-cache. Because this material is not taught in my university courses, I hope these questions can be helpful. My notes on these topics can be found at the bottom.</p> <h2 id="easy">Easy</h2> <ol> <li> <p>**Your model has <code class="language-plaintext highlighter-rouge">n_layers=32</code>, <code class="language-plaintext highlighter-rouge">n_heads=32</code>, <code class="language-plaintext highlighter-rouge">d_head=128</code>, and uses bfloat16 precision. Given an input with sequence length <code class="language-plaintext highlighter-rouge">L=64</code> and <code class="language-plaintext highlighter-rouge">B=4</code>, how many FLOPs does it take to compute attention <code class="language-plaintext highlighter-rouge">A(X) = softmax(Q K^T / \sqrt(d)) V</code>?</p> </li> <li> <p><strong>Will using a KV cache help you if you are memory bound or compute bound?</strong></p> </li> <li> <p><strong>Your model has <code class="language-plaintext highlighter-rouge">n_layers=32</code>, <code class="language-plaintext highlighter-rouge">n_heads=32</code>, <code class="language-plaintext highlighter-rouge">d_head=128</code> and uses bfloat16 precision. How much storage does a KV cache require for a single token? What about if we have <code class="language-plaintext highlighter-rouge">B*L</code> tokens where <code class="language-plaintext highlighter-rouge">B</code> is the batch size and <code class="language-plaintext highlighter-rouge">L</code> is the sequence length?</strong></p> </li> <li> <p><strong>How many FLOPs will a KV cache save you? Calculate KV cache FLOPS savings: batch_size=B, context_length=L, generate next_n tokens. What’s the speedup?</strong> <em>Without cache: 6×B×(L+next_n)×d_model² total FLOPS. With cache: 6×B×L×d_model² (initial) + 2×B×next_n×d_model² (generation). Speedup = 3×(L+next_n)/(3×L+next_n). For L»next_n, approaches 3× speedup.</em></p> </li> </ol> <h2 id="medium">Medium</h2> <ol> <li> <p><strong>Your model has <code class="language-plaintext highlighter-rouge">n_layers=32</code>, <code class="language-plaintext highlighter-rouge">n_heads=32</code>, <code class="language-plaintext highlighter-rouge">d_head=128</code>, and uses bfloat16 precision and a KV cache. At what sequence length does KV cache exceed 1GB bytes for batch_size=1?</strong></p> <p>The kv cache has shape <code class="language-plaintext highlighter-rouge">(2, B, L, n_layers, n_heads, d_head)</code> which takes up <code class="language-plaintext highlighter-rouge">M=n_bytes*2*B*L*n_layers*n_heads*d_head</code> bytes. Here <code class="language-plaintext highlighter-rouge">n_bytes = 16 bits/8 = 2</code> bytes and <code class="language-plaintext highlighter-rouge">M=1GB=1e+9</code> bytes. Therefore, 1e+9 = 2x1×L×2×32×32×128 = 524,288×L ≈ 5e+6 L bytes. L ≈ 1e+9/5e+6 ≈ 2,000 tokens. After 2,000 tokens, the kv cache will exceed 1GB. This is why long conversations quickly exhaust GPU memory.</p> </li> <li> <p><strong>Your GPU has 24GB of memory and like before, your model has <code class="language-plaintext highlighter-rouge">n_layers=32</code>, <code class="language-plaintext highlighter-rouge">n_heads=32</code>, <code class="language-plaintext highlighter-rouge">d_head=128</code> and uses bfloat16 precision and a KV cache. How many users can perform inference simultaneously with 500-token sequences vs 2000-token sequences?</strong></p> <p>The kv cache has shape <code class="language-plaintext highlighter-rouge">(2, B, L, n_layers, n_heads, d_head)</code> which takes up <code class="language-plaintext highlighter-rouge">M=n_bytes*2*B*L*n_layers*n_heads*d_head</code> bytes. Notice <code class="language-plaintext highlighter-rouge">24GB = 2.4e+10</code>.</p> <p><code class="language-plaintext highlighter-rouge">L=500</code>: <code class="language-plaintext highlighter-rouge">2.4e+10 = 2 x 2 x B x 500 x 32 x 32 x 128</code>. <code class="language-plaintext highlighter-rouge">B = 24GB/(524KB x 500) ≈ 91</code>. At most you can have <code class="language-plaintext highlighter-rouge">B=91</code> different users asking this chatbot questions simultaneously.</p> <p><code class="language-plaintext highlighter-rouge">L=2000</code>: <code class="language-plaintext highlighter-rouge">2.4e+10 = 2 x 2 x B x 2000 x 32 x 32 x 128</code>. <code class="language-plaintext highlighter-rouge">B = 24GB/(524KB x 2000) ≈ 22</code>. At most you can have <code class="language-plaintext highlighter-rouge">B=22</code> different users asking this chatbot questions simultaneously.</p> </li> <li> <p><strong>A model spends 60% of time on memory reads during generation. What does this tell you about compute vs memory bandwidth?</strong></p> <p>Memory bandwidth is the bottleneck, not compute. GPU compute units are idle 60% of the time waiting for data. We know it’s bandwidth (not a slow computation) because reading cached data should be fast - if it takes 60% of time, the memory system can’t supply data fast enough for the compute units.</p> </li> </ol> <h2 id="hard">Hard</h2> <ol> <li> <p><strong>A model has n_layers, n_heads, d_head, and uses n_bytes precision and a KV cache. When generating ALL L tokens sequentially (tokens 1, 2, 3, …, L) with batch size B, what is the total cumulative memory read from the KV cache and what is the total cumulative memory written to the KV cache?</strong></p> <p>When generating the <code class="language-plaintext highlighter-rouge">l</code>-th token (<code class="language-plaintext highlighter-rouge">1≤l≤L</code>), the KV cache stores the <code class="language-plaintext highlighter-rouge">l-1</code> previous keys and values, has shape <code class="language-plaintext highlighter-rouge">(2, B, l-1, n_layers, n_heads, d_head)</code>, and takes up <code class="language-plaintext highlighter-rouge">M(l) = n_bytes × 2 × B × (l-1) × n_layers × n_heads × d_head</code> bytes.</p> <p><strong>Memory Read:</strong> When generating the <code class="language-plaintext highlighter-rouge">l</code>-th token, we must read the entire KV cache containing all <code class="language-plaintext highlighter-rouge">l-1</code> previous tokens, requiring <code class="language-plaintext highlighter-rouge">M(l)</code> bytes. The cumulative memory read across ALL L tokens is:</p> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code> R(L) = ∑(l=1 to L) M(l)
     = n_bytes × 2 × B × n_layers × n_heads × d_head × ∑(l=1 to L) (l-1)
     = n_bytes × 2 × B × n_layers × n_heads × d_head × L×(L-1)/2
</code></pre></div> </div> <p>(Here, we used the identity that <code class="language-plaintext highlighter-rouge">\sum_{i=0}^n i = (i+1)*i/2</code> where <code class="language-plaintext highlighter-rouge">i=l-1</code>.)</p> <p><strong>Memory Write:</strong> When generating the <code class="language-plaintext highlighter-rouge">l</code>-th token, we write only the new key-value pair for that token: <code class="language-plaintext highlighter-rouge">n_bytes × 2 × B × n_layers × n_heads × d_head</code> bytes (constant per token). The cumulative memory written across ALL <code class="language-plaintext highlighter-rouge">L</code> tokens is:</p> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code> W(L) = ∑(l=1 to L) (n_bytes × 2 × B × n_layers × n_heads × d_head)
      = L × (n_bytes × 2 × B × n_layers × n_heads × d_head)
</code></pre></div> </div> </li> <li> <p><strong>Which grows more quickly: cumulative memory reads from or cumulative memory writes to the KV cache? If we have a sequence of <code class="language-plaintext highlighter-rouge">L=1000</code> tokens, how many more/fewer times do we cumulatively read than cumulatively write? What are the implications of this?</strong></p> <p>From the previous question we know that the cumulative reads from the KV cache is <code class="language-plaintext highlighter-rouge">R(L) = n_bytes × 2 × B × n_layers × n_heads × d_head × L×(L-1)/2</code> and the cumulative writes to the KV cache is <code class="language-plaintext highlighter-rouge">W(L) = L × n_bytes × 2 × B × n_layers × n_heads × d_head</code>. Notice that memory reads grows quadratically with <code class="language-plaintext highlighter-rouge">L</code> but memory writes grow linearly with <code class="language-plaintext highlighter-rouge">L</code>. So the cumulative reads grow faster than the cumulative writes.</p> <p>The read-write ratio is <code class="language-plaintext highlighter-rouge">R/W = (L-1)/2</code> meaning we read <code class="language-plaintext highlighter-rouge">(L-1)/2</code> times more data than we write. For <code class="language-plaintext highlighter-rouge">L=1000</code> tokens, we read <code class="language-plaintext highlighter-rouge">(1000-1)/2~500</code> times more data than we write.</p> <p>Implications: If our model becomes memory-bound, this is likely from reading from memory not from writing to memory.</p> </li> <li> <p><strong>How do you handle KV cache across multiple GPUs? Explain how each parallelism strategy works with the KV-cache: model parallelisim, data parallelsim, sequence apralellim, pipeline paralellsim?</strong> <em>Model parallelism: partition cache by layers across GPUs, but attention requires all-gather communication. Sequence parallelism is challenging due to autoregressive dependencies. Pipeline parallelism works but complicates cache management.</em></p> </li> </ol> <h3 id="system-design--trade-offs">System Design &amp; Trade-offs</h3> <ol> <li> <p><strong>You’re serving a chatbot. User conversations average 50 tokens but 1% go to 10,000 tokens. How do you handle KV cache memory?</strong></p> <p>Implement sliding window attention (keep only last N tokens) or progressive offloading (move old cache entries to CPU/disk). The 1% tail drives 99% of memory costs, so optimize for the outliers.</p> </li> <li> <p><strong>Production system: 95th percentile latency matters more than throughput. KV cache or large batches?</strong> <em>KV cache for consistent low latency per user, even if total throughput (users/sec) is lower. Large batches increase individual request latency due to queuing effects.</em></p> </li> <li> <p><strong>Two GPUs: 16GB with 2TB/s bandwidth vs 32GB with 1TB/s bandwidth. Which is better for long conversations?</strong> <em>Depends on sequence length. Short sequences (memory bandwidth bound): 16GB GPU wins. Long sequences (memory capacity bound): 32GB GPU wins. The crossover point depends on your specific workload.</em></p> </li> <li> <p><strong>Inference cost optimization: KV cache uses 2× memory but 3× faster generation. At what utilization rate do you break even?</strong> <em>If you can keep GPUs 66%+ utilized with KV cache (⅔ of capacity), the 3× speed improvement compensates for 2× memory cost. Below 66% utilization, large batches without KV cache may be more cost-effective.</em></p> </li> <li> <p><strong>User requests 5 different continuations of same prompt. KV cache strategy?</strong> <em>Cache the common prompt prefix once, then branch KV cache only for the different continuations. This avoids recomputing the shared 90% of work while only duplicating the divergent portions.</em></p> </li> <li> <p><strong>Why might a model perform WORSE with KV cache enabled in some scenarios?</strong> <em>Memory pressure causing GPU memory swapping to CPU, memory bandwidth saturation slowing all operations, or cache management overhead (copying, allocation) exceeding computational savings for short sequences.</em></p> </li> </ol> <h3 id="advanced">Advanced</h3> <ol> <li> <p><strong>Flash Attention reduces memory usage. How does this interact with KV cache benefits?</strong> <em>Flash Attention optimizes attention computation memory (intermediate activations), while KV cache optimizes recomputation across time steps. They’re complementary - Flash Attention reduces per-step memory, KV cache reduces cross-step computation.</em></p> </li> <li> <p><strong>In transformer training vs inference: why is KV cache irrelevant for training?</strong> <em>Training uses teacher forcing - processes entire sequences in parallel with full attention matrices. No autoregressive generation step-by-step, so no opportunity to reuse previous computations.</em></p> </li> <li> <p><strong>Model uses rotary positional embeddings (RoPE). How does this affect what we cache?</strong> <em>Cache unrotated K,V vectors and apply position-dependent rotation during attention computation. This is because the rotation depends on the relative position between query and key, which changes for each new token.</em></p> </li> <li> <p><strong>A sequence has repeated phrases. Could we compress KV cache by deduplicating similar K,V vectors?</strong> <em>Theoretically possible, but positional embeddings make even identical tokens have different representations. The attention mechanism depends on position, not just content, making deduplication complex and potentially harmful to model quality.</em></p> </li> <li> <p><strong>Mixture of Experts (MoE) model: different tokens activate different experts. How does this complicate KV cache?</strong> <em>Each expert may need separate KV caches if they have different dimensions, or the routing decisions affect which cached values are relevant. Cache size scales with number of active experts per token.</em></p> </li> <li> <p><strong>Streaming generation: user types while model generates. How do you update KV cache mid-generation?</strong> <em>Invalidate cache from the interruption point onward, recompute from the user’s new input position. This requires careful bookkeeping of which cache entries correspond to which part of the conversation state.</em></p> </li> <li> <p><strong>Speculative decoding: generate multiple tokens in parallel, then verify. How does KV cache work here?</strong> <em>Cache optimistically for all speculated tokens, but maintain checkpoints to rollback if speculation fails. This creates a tree of potential cache states that must be managed efficiently.</em></p> </li> <li> <p><strong>Model pruning removes 50% of attention heads. How does this affect KV cache memory and performance trade-offs?</strong> <em>Memory usage halves (n_heads reduces by 50%), but attention quality may degrade, potentially requiring longer sequences for same performance. Need to rebalance the memory savings vs quality trade-off.</em></p> </li> <li> <p><strong>We store K,V per head in KV cache. Do we also need to store the concatenated output after multi-head attention?</strong> <em>No, only store individual K,V per head. The concatenated output gets recomputed each time because it depends on the new query. KV cache only stores the reusable components (keys and values), not query-dependent results.</em></p> </li> <li> <p><strong>When we say the KV cache memory “grows linearly with sequence length,” do we mean input prompt length or total length including generated tokens?</strong> <em>Total length including all generated tokens. During autoregressive generation, sequence length = original_prompt + tokens_generated_so_far. Each new token increases this total length by 1.</em></p> </li> <li> <p><strong>Batch processing sequences of different lengths with padding: do shorter sequences waste KV cache memory?</strong> <em>In naive implementations, yes - all sequences get padded to max_length, wasting memory. Better implementations use attention masks to ignore padding during computation and variable-length caching to avoid storing padding positions in the KV cache.</em></p> </li> <li> <p><strong>What is Grouped Query Attention (GQA): multiple heads share K,V. How does this change the storage formula for a model using a KV cache?</strong> GQA is multiple heads share K,V. Formula becomes: 2 × n_bytes × n_layers × n_kv_heads × d_head (where n_kv_heads &lt; n_heads). If 32 query heads share 8 KV heads, you get 4× memory savings while maintaining most of the attention quality.</p> </li> <li> <p><strong>Beam search: each beam needs its own KV cache. How does this explode memory?</strong> <em>Memory scales as k_beams × sequence_length × cache_size. With 8 beams and 1000 tokens, you need 8× more memory than greedy decoding. When beams split from same parent, cache copying creates temporary memory spikes beyond this 8× baseline.</em></p> </li> <li> <p><strong>What memory and time overheads does KV cache add?</strong> <em>Memory: 2×n_bytes×n_layers×n_heads×d_head×B×L storage overhead. Time: memory allocation/deallocation, cache management, and quadratic read bandwidth growth (reading more cached data for each new token). These can outweigh benefits for short sequences.</em></p> </li> <li> <p><strong>Can we be memory-bound during forward pass but FLOPS-bound during sampling?</strong> <em>Yes! Forward pass reads massive amounts of cached K,V data (memory-bound). Sampling step does text generation, top-k filtering, probabilistic sampling (FLOPS-bound). Different parts of inference have different bottlenecks depending on sequence length and model size.</em></p> </li> </ol> <hr> <h1 id="notes">Notes</h1> <p>Here are my notes, also written with claude.</p> <h2 id="flops">FLOPS</h2> <p><strong>FLOPS (Floating Point Operations Per Second)</strong> counts arithmetic operations (add, multiply, etc.).</p> <p><strong>Matrix-Vector Multiplication:</strong> A(m×k) @ v(k×1) = <code class="language-plaintext highlighter-rouge">2×m×k</code> FLOPS (k multiply-adds for each of m output elements). The factor of 2 comes from each output element requiring k multiplications + k additions.</p> <p><strong>Matrix-Matrix Multiplication:</strong> A(m×k) @ B(k×n) = <code class="language-plaintext highlighter-rouge">2×m×k×n</code> FLOPS (k multiply-adds for each of m×n output elements). The factor of 2 comes from each output element requiring k multiplications + k additions.</p> <p><strong>Compute Bound (FLOPs Bound):</strong> The bottleneck is arithmetic operations. GPU compute units are fully utilized, but memory can supply data faster than it’s consumed. Adding more compute power would speed up the process.</p> <p><strong>Memory Bound (Bandwidth Bound):</strong> The bottleneck is data movement. GPU compute units are idle waiting for data from memory. Memory bandwidth cannot supply data fast enough for the available compute. Adding more memory bandwidth would speed up the process.</p> <h2 id="attention">Attention</h2> <p><strong>Parameter Definitions:</strong></p> <ul> <li> <strong>B:</strong> batch size (number of sequences processed in parallel)</li> <li> <strong>L:</strong> sequence length (number of tokens in each sequence)</li> <li> <strong>d_model:</strong> model dimension (hidden size, e.g., 4096 for large models)</li> </ul> <p><strong>Matrix Dimensions &amp; Descriptions:</strong></p> <ul> <li> <strong>X (input tokens):</strong> (B, L, d_model) - batch of token sequences</li> <li> <strong>W_q (query weights):</strong> (d_model, d_model) - learned projection for queries</li> <li> <strong>W_k (key weights):</strong> (d_model, d_model) - learned projection for keys</li> <li> <strong>W_v (value weights):</strong> (d_model, d_model) - learned projection for values</li> <li> <strong>Q (queries):</strong> (B, L, d_model) - what each token is looking for</li> <li> <strong>K (keys):</strong> (B, L, d_model) - what each token represents</li> <li> <strong>V (values):</strong> (B, L, d_model) - information content of each token</li> </ul> <p><strong>Full Attention Equation:</strong> Attention(Q,K,V) = softmax(QK^T / √d_model) @ V</p> <p><strong>FLOPS Breakdown:</strong></p> <ul> <li>Q = X @ W_q: <code class="language-plaintext highlighter-rouge">2 × B × L × d_model²</code> FLOPS</li> <li>K = X @ W_k: <code class="language-plaintext highlighter-rouge">2 × B × L × d_model²</code> FLOPS</li> <li>V = X @ W_v: <code class="language-plaintext highlighter-rouge">2 × B × L × d_model²</code> FLOPS</li> <li>QK^T: <code class="language-plaintext highlighter-rouge">2 × B × L² × d_model</code> FLOPS</li> <li>softmax(QK^T / √d_model): <code class="language-plaintext highlighter-rouge">C₁ × B × L²</code> FLOPS (constant operations per element)</li> <li>softmax(scores) @ V: <code class="language-plaintext highlighter-rouge">2 × B × L² × d_model</code> FLOPS</li> </ul> <p><strong>Total FLOPS:</strong> <code class="language-plaintext highlighter-rouge">6 × B × L × d_model² + 4 × B × L² × d_model + C₁ × B × L²</code></p> <p><strong>KV Cache Impact:</strong> Only the first term <code class="language-plaintext highlighter-rouge">6 × B × L × d_model²</code> changes with KV caching. The terms <code class="language-plaintext highlighter-rouge">4 × B × L² × d_model + C₁ × B × L²</code> do not change with KV cache. For simplicity, we only focus on this firt term in the rest of this post. But in practice you must add back the two unchanging terms.</p> <h2 id="kv-cache">KV Cache</h2> <p><strong>KV Cache</strong> stores the computed key and value vectors from previous tokens during autoregressive generation, avoiding redundant recomputation. Instead of recalculating K and V for all tokens at each step, we cache them and only compute new entries.</p> <p><strong>Example</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Prompt: "The weather today"
Target: Generate " is sunny"

Prefill Phase:
- Input: ["The", "weather", "today"] (3 tokens)
- Compute: K₁,V₁, K₂,V₂, K₃,V₃ in parallel
- Cache: Store all 3 K,V pairs
- Time: Fast parallel processing

Generation Phase:
Token 4 " is":
- Read: K₁,V₁, K₂,V₂, K₃,V₃ from cache
- Compute: Q₄, K₄, V₄
- Attention: Q₄ @ [K₁,K₂,K₃,K₄]^T @ [V₁,V₂,V₃,V₄]
- Cache: Append K₄,V₄

Token 5 " sunny":
- Read: K₁,V₁, K₂,V₂, K₃,V₃, K₄,V₄ from cache
- Compute: Q₅, K₅, V₅
- Attention: Q₅ @ [K₁,K₂,K₃,K₄,K₅]^T @ [V₁,V₂,V₃,V₄,V₅]
- Cache: Append K₅,V₅
</code></pre></div></div> <p><strong>Implementation</strong> To store the previous keys and value, the KV cache is defined as a tensor</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cache = Tensor.empty(2, B, L, n_layers, n_heads, d_head)
</code></pre></div></div> <p>where:</p> <ul> <li>2: separate storage for keys and values</li> <li>B, L: the number of tokens (L) across all sequences (B)</li> <li>n_layers, n_heads, d_head: the number of keys and value we have across all layers of a model where the keys are <code class="language-plaintext highlighter-rouge">cache[0]</code> and the values are <code class="language-plaintext highlighter-rouge">cache[1]</code>. The kv cache works by reading from and writing to this tensor.</li> </ul> <p>To find the key from the 6th token in the 3rd sequence at the 9th head from 14th layer of the model, we would do</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cache[0, 3, 6, 14, 9]
</code></pre></div></div> <p>Naively, this kind of naive KV-cache only works for greedy sampling and it does not work for more complicated sampling schemes like min-p or beam decoding.</p> <p><strong>Memory Requirement:</strong> This requires storing <code class="language-plaintext highlighter-rouge">2 × B × L × n_layers × n_heads × d_head × n_bytes</code> total bytes in memory because the cache is a tensor of shape <code class="language-plaintext highlighter-rouge">2, B, L, n_layers, n_heads, d_head</code> and each element in that tensor takes up <code class="language-plaintext highlighter-rouge">n_bytes</code>.</p> <p><strong>Prefill Phase (Time to First Token - TTFT):</strong></p> <ul> <li>Process entire input prompt in parallel</li> <li>Compute K,V for ALL input tokens simultaneously: O(L_input)</li> <li>Initialize KV cache with input token representations</li> <li>High memory bandwidth and compute utilization</li> <li>TTFT dominated by this parallel processing of input</li> </ul> <p><strong>Generation Phase (Time Between Tokens):</strong></p> <ul> <li>Process one new token at a time autoregressively</li> <li>Compute K,V only for new token: O(1) per token</li> <li>Read entire cached history for attention: O(L_total)</li> <li>Memory bandwidth becomes bottleneck as sequence grows</li> </ul> <p><strong>When FLOPS Bound (KV Cache Helps):</strong></p> <ul> <li>Without cache: Spend time computing Q,K,V for all tokens (6 × d_model² FLOPS)</li> <li>With cache: Only compute Q for new token (2 × d_model² FLOPS)</li> <li> <strong>Result</strong>: 3× speedup because we eliminated computational work</li> </ul> <p><strong>When Memory Bound (KV Cache May Hurt):</strong></p> <ul> <li>Without cache: Read input tokens, compute everything fresh</li> <li>With cache: Read massive amounts of cached K,V data plus compute Q</li> <li> <strong>Result</strong>: More memory traffic, potentially slower despite less computation</li> </ul> <p><strong>Example</strong>: Long sequences (1000+ tokens) often become memory bound because reading cached data dominates the time, making the FLOPS savings irrelevant.</p> <h3 id="kv-cache-pros-and-cons">KV Cache Pros and Cons</h3> <table> <thead> <tr> <th><strong>Advantages</strong></th> <th><strong>Disadvantages</strong></th> </tr> </thead> <tbody> <tr> <td> <strong>3× FLOPS reduction</strong> for Q,K,V computation</td> <td> <strong>Linear memory growth</strong> with sequence length</td> </tr> <tr> <td> <strong>Enables real-time generation</strong> for interactive applications</td> <td> <strong>Reduces maximum batch size</strong> due to memory constraints</td> </tr> <tr> <td> <strong>Critical for long context</strong> models (would be unusably slow otherwise)</td> <td> <strong>Memory bandwidth bottleneck</strong> for very long sequences</td> </tr> <tr> <td> <strong>Powers production chat systems</strong> at scale</td> <td> <strong>Beam search memory explosion</strong> when caches are copied</td> </tr> <tr> <td> <strong>Amortizes compute cost</strong> over conversation length</td> <td> <strong>No benefit for training</strong> (only inference optimization)</td> </tr> <tr> <td> <strong>Enables streaming responses</strong> for better UX</td> <td> <strong>Overhead for short sequences</strong> (&lt; 50 tokens)</td> </tr> <tr> <td> <strong>Facilitates longer conversations</strong> without timeout</td> <td> <strong>Cache sharing impossible</strong> between different users</td> </tr> </tbody> </table> <h3 id="flops-analysis">FLOPS Analysis</h3> <table> <thead> <tr> <th>Generation</th> <th>Without KV Cache</th> <th>With KV Cache</th> <th>Explanation</th> </tr> </thead> <tbody> <tr> <td><strong>Single token (Lth token, batch size B)</strong></td> <td><code class="language-plaintext highlighter-rouge">3 × 2 × d_model² × B + C</code></td> <td><code class="language-plaintext highlighter-rouge">2 × d_model² × B + C</code></td> <td>Without: compute Q,K,V from scratch (3 matrices × 2 FLOPS factor). With: only compute Q, reuse cached K,V. C = attention matrix operations (same for both)</td> </tr> <tr> <td><strong>Cumulative tokens (tokens 1, …, L, batch size B)</strong></td> <td><code class="language-plaintext highlighter-rouge">3 × 2 × d_model² × B × L + C × L</code></td> <td><code class="language-plaintext highlighter-rouge">2 × d_model² × B × L + C × L</code></td> <td>Without: recompute Q,K,V for every token. With: compute Q for each new token only. C scales with sequence length</td> </tr> </tbody> </table> <h3 id="kv-cache-memory--io">KV Cache Memory &amp; I/O</h3> <table> <thead> <tr> <th>Generation</th> <th>Memory Stored</th> <th>Bandwidth: Read</th> <th>Bandwidth: Write</th> <th>Explanation</th> </tr> </thead> <tbody> <tr> <td><strong>Single token (Lth token, batch size B)</strong></td> <td><code class="language-plaintext highlighter-rouge">2 × n_bytes × n_layers × n_heads × d_head × B × L</code></td> <td><code class="language-plaintext highlighter-rouge">2 × n_bytes × n_layers × n_heads × d_head × B × (L-1)</code></td> <td><code class="language-plaintext highlighter-rouge">2 × n_bytes × n_layers × n_heads × d_head × B</code></td> <td>Memory: total cache size grows with L. Read: access all previous tokens for attention. Write: store current token’s K,V</td> </tr> <tr> <td><strong>Cumulative tokens (tokens 1, …, L, batch size B)</strong></td> <td><code class="language-plaintext highlighter-rouge">2 × n_bytes × n_layers × n_heads × d_head × B × L</code></td> <td><code class="language-plaintext highlighter-rouge">2 × n_bytes × n_layers × n_heads × d_head × B × L × (L-1)/2</code></td> <td><code class="language-plaintext highlighter-rouge">2 × n_bytes × n_layers × n_heads × d_head × B × L</code></td> <td>Memory: same final size. Read: cumulative bandwidth = 0+1+2+…+(L-1) = L(L-1)/2 per batch. Write: one entry per token generated</td> </tr> </tbody> </table> <h3 id="beam-search-with-kv-cache">Beam Search with KV Cache</h3> <p><strong>Definition:</strong> Beam search maintains the k most promising sequences at each step, exploring multiple paths simultaneously to find higher-quality outputs than greedy decoding.</p> <p><strong>Algorithm:</strong></p> <ol> <li>Start with k beams (initially just the prompt)</li> <li>For each beam, generate top-r candidate next tokens</li> <li>Score all k×r candidates</li> <li>Keep top-k sequences as new beams</li> <li>Repeat until completion</li> </ol> <p><strong>Concrete Example with KV Cache:</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Model: 2 layers, 4 heads, d_head=64, n_bytes=2
Beam width k=2, candidates per beam r=3
Starting sequence: "The weather" (2 tokens)

Initial State:
Beam 1: "The weather"
KV Cache 1: K₁,V₁ (for "The"), K₂,V₂ (for "weather")
Cache size: 2×2×2×4×64 = 1,024 bytes

Beam 2: "The weather"
KV Cache 2: K₁,V₁ (for "The"), K₂,V₂ (for "weather")
Cache size: 1,024 bytes (same starting point)

Step 1: Generate third token (each beam explores 3 candidates)
Beam 1 candidates: "is" (0.6), "was" (0.3), "feels" (0.2)
Beam 2 candidates: "today" (0.5), "looks" (0.4), "seems" (0.1)

Step 2: Select top-2 sequences across all 6 candidates
Selected: "The weather is" (0.6), "The weather today" (0.5)

MEMORY EXPLOSION POINT:
New Beam 1: "The weather is"
- Needs: COPY of original Beam 1 cache + new K₃,V₃ for "is"
- Cache: K₁,V₁, K₂,V₂, K₃ⁱˢ,V₃ⁱˢ = 1,536 bytes

New Beam 2: "The weather today"
- Needs: COPY of original Beam 2 cache + new K₃,V₃ for "today"
- Cache: K₁,V₁, K₂,V₂, K₃ᵗᵒᵈᵃʸ,V₃ᵗᵒᵈᵃʸ = 1,536 bytes

Total Memory: 3,072 bytes (3× explosion from beam splitting!)
Note: The beams started identical but diverged due to different candidate selection
</code></pre></div></div> <h3 id="beam-search-flops--memory-analysis">Beam Search FLOPS &amp; Memory Analysis</h3> <table> <thead> <tr> <th>Generation</th> <th>FLOPS (vs Greedy)</th> <th>Memory Stored</th> <th>Bandwidth: Read</th> <th>Explanation</th> </tr> </thead> <tbody> <tr> <td><strong>Single token (Lth token, k beams)</strong></td> <td><code class="language-plaintext highlighter-rouge">k × (2 × d_model² + C)</code></td> <td><code class="language-plaintext highlighter-rouge">k × 2 × n_bytes × n_layers × n_heads × d_head × L</code></td> <td><code class="language-plaintext highlighter-rouge">k × 2 × n_bytes × n_layers × n_heads × d_head × (L-1)</code></td> <td>k separate sequences, each needs own KV cache and computation</td> </tr> <tr> <td><strong>Cumulative tokens (tokens 1, …, L, k beams)</strong></td> <td><code class="language-plaintext highlighter-rouge">k × (2 × d_model² × L + C × L)</code></td> <td><code class="language-plaintext highlighter-rouge">k × 2 × n_bytes × n_layers × n_heads × d_head × L</code></td> <td><code class="language-plaintext highlighter-rouge">k × 2 × n_bytes × n_layers × n_heads × d_head × L × (L-1)/2</code></td> <td>Memory can temporarily spike beyond k× during beam splitting when caches must be copied</td> </tr> </tbody> </table> <p><strong>Key Insight:</strong> Beam search with KV cache uses k× more memory than greedy decoding, but beam splitting during search can cause temporary memory explosions when multiple beams inherit from the same parent cache.</p> <h2 id="memory-bound-vs-flops-bound">Memory Bound vs. FLOPS Bound</h2> <h3 id="definitions">Definitions</h3> <p><strong>FLOPS Bound (Compute Bound):</strong> The bottleneck is arithmetic operations. GPU compute units are fully utilized, but memory can supply data faster than it’s consumed. Adding more compute power would speed up the process.</p> <p><strong>Memory Bound (Bandwidth Bound):</strong> The bottleneck is data movement. GPU compute units are idle waiting for data from memory. Memory bandwidth cannot supply data fast enough for the available compute. Adding more memory bandwidth would speed up the process.</p> <h3 id="how-to-identify">How to Identify</h3> <ul> <li> <strong>FLOPS Bound</strong>: High GPU utilization (90%+), compute units busy</li> <li> <strong>Memory Bound</strong>: Low GPU utilization despite high memory traffic, compute units waiting</li> </ul> <h3 id="kv-cache-impact">KV Cache Impact</h3> <p><strong>When FLOPS Bound (KV Cache Helps):</strong></p> <ul> <li>Without cache: Spend time computing Q,K,V for all tokens (6 × d_model² FLOPS)</li> <li>With cache: Only compute Q for new token (2 × d_model² FLOPS)</li> <li> <strong>Result</strong>: 3× speedup because we eliminated computational work</li> </ul> <p><strong>When Memory Bound (KV Cache May Hurt):</strong></p> <ul> <li>Without cache: Read input tokens, compute everything fresh</li> <li>With cache: Read massive amounts of cached K,V data plus compute Q</li> <li> <strong>Result</strong>: More memory traffic, potentially slower despite less computation</li> </ul> <p><strong>Example</strong>: Long sequences (1000+ tokens) often become memory bound because reading cached data dominates the time, making the FLOPS savings irrelevant.</p> <h2 id="resources">Resources</h2> <p>Some great resources I found:</p> <ol> <li>https://kipp.ly/transformer-inference-arithmetic/</li> <li>https://blog.eleuther.ai/transformer-math/</li> <li>https://r4j4n.github.io/blogs/posts/kv/</li> <li>https://medium.com/data-science/deep-dive-into-kv-caching-in-mistral-7e0cea8409a1</li> </ol> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/2018-12-22-distill.bib"></d-bibliography><div id="giscus_thread" style="max-width: 800px; margin: 0 auto;"> <script>let giscusTheme=localStorage.getItem("theme"),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"eitanturok/eitanturok.github.io","data-repo-id":"","data-category":"Comments","data-category-id":"","data-mapping":"title","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Eitan Turok. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>